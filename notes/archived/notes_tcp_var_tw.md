net.ipv4.tcp_tw_recycle
启用快速回收TIME-WAIT连接

net.ipv4.tcp_tw_reuse
允许重用TIME-WAIT连接

当主动关闭的一段调用close的时候， Socket需要徘徊一段时间延迟关闭（lingering)，这段时间TCP需要将缓冲区中的数据发送完毕后才发FIN
发完数据后向对端发送FIN，以表示不再有数据需要发送，从而进入FIN_WAIT_1状态，如果收到ack，则进入FIN_WAIT_2状态  ,然后等待被动关闭端通知应用程序调用socket.close()关闭连接，当主动关闭方收到FIN的时候进入TIME_WQIT状态

以上是正常的方式关闭连接，客户端的数据会确保安全地被投递

然而，应用程序可以选择禁止以上的行为：

有以下两种行为：
第一种：内核缓冲区中的数据将会丢弃，不使用标准的四次握手关闭连接，而是放一个RST到对端，对端检测到RST时立即销毁连接，主动打开的一端不会进入TIME_WAIT状态

第二种：如果内核发送缓冲区中仍然有数据，此时调用close（）时线程会休眠直至数据全部发送完成或linger定时器过期。如果缓冲区数据被成功发送，则进入正常方式关闭连接，否则发送RST，并且丢弃剩余未发送数据。

很多调优建议将上述两个选项设置为1,，以减少处于TIME_WAIT状态的连接的数量，但是这通常会产生很多问题。

资源占用

每秒处理1W个新连接，1分钟处理60W个新连接，如果这60w个都处于TIME-WAIT状态1分钟的话，那么需要消耗多少资源呢？

内存：

"tcp established hash table": 存储活跃连接



 
