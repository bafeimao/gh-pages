## TCP/IP FAQ
===

### IP数据包何时会发生重复
加入某个路由器将收到的IP数据报转发到它的2个不同的网络接口，那么就存在两个相同的IP数据包发往下一站，并最终到达目标主机，TCP已经处理了IP数据报重复的问题，UDP没有处理，UDP应用程序需要自行处理（如果必要的话）

### IP层为什么会发生数据报乱序
发送端依次发送A和B分组，但到目标主机时可能B先于A，这是由于中间节点选路不同造成的。

### 名词解释：分组，报文，报文段，数据报，数据帧
报文：message，网络中交换与传输的数据单元。
分组：一般性地表示任何类型的报文
报文段：由TCP传递给IP的信息单位称为报文段或段(segment)，包含首部+数据。

> A TCP segment consists of a segment header and a data section
> 
> https://en.wikipedia.org/wiki/TCP_segment#TCP_segment_structure

数据报：数据报是通过网络传输的数据的基本单元，包含首部和数据，例如：IP数据报，UDP数据报
数据帧：数据链路层的协议数据单元，它包括三部分：帧头，数据部分，帧尾。例如以太网数据帧。

### 发送分组到广播地址的主机自己能否也能接收到该分组？
可以，当以太网驱动程序识别出目的地址是广播地址后，它就把分组送到网络上，同时传一份拷贝给环回接口

### 最大报文段（MSS)
TCP中的名词MSS表示传往另一端的最大**数据**长度（不包括TCP首部），这里容易造成混淆，因为我们常说的TCP segment（TCP报文段）是包括TCP首部的，而MSS表示接收端仅接收不大于该值的报文段。

### [PENDING]如果发送端MSS为1460，假设TCP要传送的数据为1460字节，并且此次传输时IP数据报首部中包括选项数据，那么，发送端主机还可以发送该TCP报文段吗？
可以，MSS只是用来限定发送端

### TCP建立连接时三次握手可靠吗？
不可靠，握手成功只能说明握手时的通讯是正常的，并不能保证握手之后的通讯也都是正常的，因为网络状态是复杂并且不稳定的。任意次的通讯都有可能不可靠。

### 什么是”半打开连接”（Half-Open)
如果一方已经关闭或异常终止了连接后而对方还不知道，我们将这样的连接称为“半打开连接”，也称“半开放连接”，

### TCP的复位报文段在哪些情况下会产生
1. 到不存在的端口的连接
如果A:7777请求建立到B:8888的TCP连接，但是B上没有对应8888端口的进程，当A的SYN报文段被B的TCP接收到时发现端口8888并不存在，就会向A返回一个复位报文

2. 异常终止一个连接
正常关闭一条连接是将TCP发送缓冲区中所有的数据都发完后再发FIN来终止的，这称之“有序释放”；如果我们想立即释放一条连接，而丢弃掉缓冲区中尚未发送的数据，可以通过向对端发送RST复位报文段来实践，这称之为“异常释放”。API中选项SO_LINGER提供了这种异常关闭的设置。收到复位报文段要立即中断该连接，不用进行确认。

3. 检测到半打开连接
假设A:7777成功建立了一条到B:8888的连接，并且在A上开启了TCP的KeepAlive功能，此时断开A，B之间的链路并重启B的应用程序进程。2小时候后，A发来一条KeepAlive探查报文段到B，B收到报文但发现没有这个连接的信息（因为B重启了进程，目前还没有任何连接信息），则B就向A发送一条RST复位报文段，A收到RST后立即中断连接。

### 为何TCP的KeepAlive探查每隔75秒发送，这和TCP超时重发定时器的指数退避机制是否矛盾？

### TCP KeepAlive功能的优缺点
优点：
1. 提供透明的检测半打开连接的功能，应用层提供实现会更困难和繁琐
2. 比应用层实现效率更高，这是因为：
    a. 由于在TCP实现中提供的支持，并运行在内核层，所以执行效率更高
    b. 发送的探查报文段更短（没有数据，只包含IP和TCP头部）
3. 如果连接不是空闲的就不会发送探测报文（当然了，应用层也可以实现）

缺点：
1. 发送探测报文间隔时间为2小时，这往往不符合应用程序的具体需求
2. 如果路径中的某个路由节点正处在维护或更换状态中，探测报文往往会引起一个非常好的连接断开

### TCP为什么需要坚持定时器
TCP是通过向对端发送窗口通告ACK来告知接收端可滑动窗口以发送更多的数据，我们知道，TCP不对ACK进行确认（注意理解：数据和ACK合并发送的报文段是要确认的），如果发生丢失同时通告窗口为0，则发送端一直等待接收端发来窗口更新的报文，而接收端实际已经发送过窗口更新，这就形成了死循环，而造成连接空闲，假如应用层实现了空闲连接检测机制的话，则可能会主动终端空闲的连接。

TCP是通过在发送端主动定时发送窗口探查报文来解决以上问题的。

探查报文带一个字节，并且从接收端可接受的下一个序号开始，因此接收端收到该报文段是需要确认的。如果接收端一直不确认，发送端也是需要重发该窗口探查报文的，重发定时机制和TCP重发定时器指数退避一致，只是取值范围为5-60，因此定时器触发的依次时序列为：5，5，6，12，24，48，60（正常的TCP报文重传定时器溢出时间序列为1.5，3，6，12，24，48，64，64，64。。。）

### 窗口探查报文什么时候被发送，内部机制是什么？
TCP在发现通告窗口为0时的5s后开始发送窗口探查报文段，该报文段包含一个字节，但接收端收到该字节时并不对其确认，而是发送上一次确认的字节序号ACK给发送端并带上此时窗口大小，此时有两种情况：

### 关于糊涂窗口综合症以及避免措施
糊涂窗口综合症（Silly Window Syndrome，SWS)是指发送端可能会发送小数据（比如1字节），接收端也会通告小窗口，这样会造成很多小分组在网络上交换，使得网络利用率不高并且会造成拥堵。

解决的措施：
发送端：不通告小窗口，除非窗口可以增长到min(mss, recv_buf/2)

接收端：满足以下条件时才发送数据
1. 达到通告窗口的一半
2. 达到最大报文段长度
3. 发送完手头所有的数据（小分组），这需要分以下情况：
    . 启用了nagle算法，并且没有未确认的报文段
    . 未启用nagle算法，直接发小分组（是允许的，否则交互数据流的实时性就没法保证了）
    . 主动关闭

说明：条件1和2不管是否启用了nagle算法都成立。nagle算法是为了减少发送微小分组在网络上的传输，那么这个小是如何界定的呢？就是条件1和2决定的，换句话说，在启用了nagle算法的情况下，如果手头累积的数据大小达到min(win/2, mss)时就应该立即发送手头的数据，而不管是否有尚未确认的数据，因为此时的待发送的数据已经不算是微小分组了。


---

### ICMP章节总结：
ICMP报文包含在IP数据报中发送的（IGMP也是），因此ICMP通常被认为是IP层的一个组成部分，它通常被IP层或更高层（UDP/TCP）使用。IP层发生的差错会通过ICMP发送给源主机，例如：
1.路由器接收到一份需要分片的IP数据报，但该数据报首部设置了DF（不分片）标志时，IP层会向源主机发送一份ICMP不可达差错报文（type=3,code=4)
2. 如果发送端发送数据速度大于接收端接受数据速度，接收端可向发送端发送"ICMP源站抑制差错报文".

ICMP所有格式的报文的前4个字段都是一样的：类型（8) + 代码（8) + checksum(16)，不同类型的报文就是有类型和代码两个字段决定的。

ICMP可分为”查询“和”差错“两种类型，对ICMP”差错“报文响应时，永远不会产生另一份差错报文，这样可以杜绝死循环，但是对”ICMP查询报文“可能会响应，比如ICMP回显请求（ping程序发送的），地址掩码请求，时间戳请求，路由器通告。

地址掩码请求：用于无盘系统在引导时获取自己的子网掩码，该ICMP报文是**广播**的。

ICMP不可达差错报文格式中一般都带有“原始IP数据包的头部（注意：包含选项） + 原始IP数据报中的数据的前8个字节”，为什么是8个字节呢，因为对于UDP或TCP首部来说，前8个字节中包含了端口信息及其他相关信息，这样便于原始IP数据报发送端接收到这个ICMP差错报文时和某个进程关联。







