/*
 * Copyright 2002-2016 XianYu Game Co. Ltd, The Inuyasha Project
 */

package com.xy.inuyasha.servers.world.template.common;

import com.google.common.base.Function;
import com.google.common.base.MoreObjects;
import com.google.common.base.Objects;
import com.google.common.collect.Lists;
import com.google.common.collect.Maps;
import com.xy.inuyasha.servers.world.common.RedisKeys;
import com.xy.inuyasha.servers.world.template.RewardPoolTemplate;
import com.xy.inuyasha.support.data.redis.RedisSupport;
import com.xy.inuyasha.support.util.Randoms;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import redis.clients.util.Pool;

import java.util.*;
import java.util.Map.Entry;

/**
 * Created by gukt on 2016/1/9.
 *
 * @author gukt
 * @version 1.0；
 * @date 2016/1/9
 */
public class RewardPool {
    private static final Logger LOGGER = LoggerFactory.getLogger(RewardPool.class);
    private static final String KEY_ITEM_HIT = "item_hit_%s_%s";
    private static final String KEY_POOL_HITS = "pool_hits_%s";

    private List<RewardEntry> entries = new ArrayList<>();
    private int EMPTY_ITEM_ID = -1;
    private int type = 1;
    private RedisSupport redisSupport = RedisSupport.getInstance();

    public static class RewardEntry {
        private int id;
        private int minNum;
        private int maxNum;
        private int weight = -1;
        private int ceil = 0;

        @Override
        public String toString() {
            return MoreObjects.toStringHelper(this)
                    .add("id", id)
                    .toString();
        }

        @Override
        public boolean equals(Object o) {
            if (this == o) return true;
            if (o == null || getClass() != o.getClass()) return false;
            RewardEntry entry = (RewardEntry) o;
            return com.google.common.base.Objects.equal(id, entry.id);
        }

        @Override
        public int hashCode() {
            return Objects.hashCode(id);
        }
    }

    public List<RewardItem> random(int poolId, long roleId, int n) {
        return random(poolId, roleId, null, 0, n, true);
    }

    /**
     * 从掉落池中随机选择出指定个数ID（可能是物品Id，也可能是奖池ID，这是由奖池类型({@link RewardPoolTemplate#getType()})决定的）
     * 因此如果需要从奖池中随机出指定个数的物品，请调用{@link com.xy.inuyasha.servers.world.common.RewardPools}的相应方法
     * <p/>
     * TODO 该方法返回值类型中的RewardItem不是很贴切，容易误导
     *
     * @param n 指定要获得Id的个数
     * @return 返回Pool中随机到的Id以及个数
     */
    public List<RewardItem> random(int poolId, long roleId, Map<Integer, Integer> guaranteeMap,
                                   int guaranteeTimes, int n) {
        return random(poolId, roleId, guaranteeMap, guaranteeTimes, n, true);
    }

    public List<RewardItem> random(int poolId, long roleId, Map<Integer, Integer> guaranteeMap,
                                   int guaranteeTimes, int n, boolean merge) {
        // 先获得不合并的道具
        List<RewardItem> rewardItems = randomWithoutMerge(poolId, roleId, guaranteeMap, guaranteeTimes, n);

        if (merge) {
            Map<Integer, RewardItem> rewardItemsById = new HashMap<>();
            for (RewardItem current : rewardItems) {
                RewardItem found = rewardItemsById.get(current.getId());
                if (found == null) {
                    rewardItemsById.put(current.getId(), current);
                } else {
                    found.setNum(found.getNum() + current.getNum());
                }
            }
            return Lists.newArrayList(rewardItemsById.values());
        } else {
            return rewardItems;
        }
    }

    public Map<Integer, Integer> randomAsMap(int n) {
        Map<Integer, Integer> itemsMap = new HashMap<>();
        Random random = new Random(System.nanoTime());

        for (int i = 0; i < n; i++) {
            int randNum = random.nextInt(10000); // 本轮先产生一个随机数
            for (RewardEntry entry : entries) {
                if (randNum <= entry.ceil) {  // 命中
                    if (entry.id != EMPTY_ITEM_ID) {
                        int num = Math.max(entry.minNum, random.nextInt(entry.maxNum + 1));
                        if (itemsMap.containsKey(entry.id)) {
                            num += itemsMap.get(entry.id);
                        }
                        itemsMap.put(entry.id, num);
                    }
                    break;
                }
            }
        }
        return itemsMap;
    }

    /**
     * 从奖池中获得不重复的道具个数
     *
     * @param n 期望获得不重复道具的个数
     * @return 返回道具的列表，注意：道具个数可能会等于n-1，因为空权重也参与计数
     */
    public Map<Integer, Integer> randomDistinct(int n) {
        Map<Integer, Integer> retMap = new HashMap<>();

        // 奖池中的物品数量小于期望的数量
        if (n > entries.size()) {
            LOGGER.info("我擦，奖池#{}中只配置了{}项，怎么随机出{}种不重复的道具？", entries, entries.size(), n);
        }
        // 奖池中的物品数量等于期望的数量（空权重也参与计数）
        else if (n == entries.size()) {
            for (RewardEntry entry : entries) {
                retMap.put(entry.id, Randoms.random(entry.minNum, entry.maxNum));
            }
            return retMap;
        }
        // 奖池中的物品数量大于期望的数量
        else {
            List<RewardEntry> currentEntries = Lists.newArrayList(entries);
            while (retMap.size() < n) {
                RewardEntry entry = random(currentEntries, 1);
                if (entry != null) {
                    retMap.put(entry.id, Randoms.random(entry.minNum, entry.maxNum));
                } else {
                    retMap.put(EMPTY_ITEM_ID, 0); // 随机到空权重，也加入计数
                }

                currentEntries.remove(entry);
                calcProbabilityByWeight(currentEntries);
            }
        }

        // 移除掉空权重
        for (Iterator<Map.Entry<Integer, Integer>> iterator = retMap.entrySet().iterator(); iterator.hasNext(); ) {
            Map.Entry<Integer, Integer> entry = iterator.next();
            if (entry.getKey() == EMPTY_ITEM_ID) {
                iterator.remove();
            }
        }

        return retMap;
    }

    private List<RewardEntry> adjustRewardEntries(List<RewardEntry> entries, PoolStats poolStats) {
        List<RewardEntry> retList = new ArrayList<>();

        // 获得当前掉落池总调用次数
        Integer poolHits = poolStats.getPoolHits();

        for (RewardEntry entry : entries) {
            // TODO Add entry to retList
        }

        return retList;
    }

    class PoolStats {
        private Map<String, Integer> statsMap;
        private int poolId;
        private int poolType;
        private long roleId;
        private Map<Integer, Integer> guaranteeMap;
        private int guaranteeTimes;

        public PoolStats(int poolId, int poolType, long roleId, Map<Integer, Integer> guaranteeMap, int guaranteeTimes) {
            this.poolId = poolId;
            this.poolType = poolType;
            this.roleId = roleId;
            this.guaranteeMap = guaranteeMap;
            this.guaranteeTimes = guaranteeTimes;
        }

        private Map<String, Integer> getStatsMap() {
            if (statsMap == null) {
                Map<String, String> map = redisSupport.hgetAll(String.format(RedisKeys.REWARD_POOL_HISTORY_STATS, roleId));

                for (Entry<String, String> entry : map.entrySet()) {
                    statsMap.put(entry.getKey(), Integer.valueOf(entry.getValue()));
                }
            }
            return statsMap;
        }

        public void savePoolStats() {
            redisSupport.hmset(String.format(RedisKeys.REWARD_POOL_HISTORY_STATS, roleId),
                    Maps.transformValues(statsMap, new Function<Integer, String>() {
                        @Override
                        public String apply(Integer input) {
                            return String.valueOf(input);
                        }
                    }));
        }

        public PoolStats incrPoolHits() {
            String key = String.format(KEY_POOL_HITS, poolId);
            Integer n = statsMap.get(key);
            statsMap.put(key, n == null ? 1 : n + 1);
            return this;
        }

        public int getItemHitNum(int itemId) {
            String key = String.format(KEY_ITEM_HIT, poolId, itemId);
            Integer n = statsMap.get(key);
            return n == null ? 0 : n;
        }

        public void setItemHitNum(int itemId, int num) {
            String key = String.format(KEY_ITEM_HIT, poolId, itemId);
            statsMap.put(key, num);
        }

        public int getPoolHits() {
            String key = String.format(KEY_POOL_HITS, poolId);
            Integer n = statsMap.get(key);
            return n == null ? 0 : n;
        }
    }

    private List<RewardItem> randomWithoutMerge(int poolId, long roleId, Map<Integer, Integer> guaranteeMap,
                                                int guaranteeTimes, int n) {
        List<RewardItem> retList = new ArrayList<>();
        Random random = new Random(System.nanoTime());

//        String poolHitCountKey = String.format(KEY_POOL_HITS, poolId);
//        Map<String, Integer> poolStatsMap = getPoolStats(roleId);

        PoolStats poolStats = new PoolStats(poolId, type, roleId, guaranteeMap, guaranteeTimes);

//        // 获得当前掉落池总调用次数
//        Integer poolInvokeTotal = poolStatsMap.get(poolHitCountKey);
//        poolInvokeTotal = poolInvokeTotal == null ? 0 : poolInvokeTotal;

        // 循环指定的轮数
        for (int i = 0; i < n; i++) {
            int randNum = random.nextInt(10000); // 每轮循环都产生一个新的随机数
//            randNum = 10000;

//            poolStatsMap.put(poolHitCountKey, ++poolInvokeTotal);

            List<RewardEntry> adjustedEntries = adjustRewardEntries(entries, poolStats.incrPoolHits());

            for (RewardEntry entry : entries) {
                // 从历史记录中获得上次该道具命中时的计数值
                String itemHitKey = String.format(KEY_ITEM_HIT, poolId, entry.id);
                Integer lastHitAt = poolStatsMap.get(itemHitKey);
                lastHitAt = lastHitAt == null ? 0 : lastHitAt;

                // 判断当前道具是否有保底掉落要求
                boolean guaranteeRequired = guaranteeMap != null && guaranteeMap.containsKey(entry.id);

                // 需要扩展的概率值
                Integer rangeExtended = 0;

                // 如果当前道具有保底掉落需求，则计算本次应该给它扩大多少概率范围
                if (guaranteeRequired) {
                    int n1 = guaranteeTimes + 1;
                    if (lastHitAt == 0 || (lastHitAt / n1) != (poolInvokeTotal / n1)) {
                        rangeExtended = ((poolInvokeTotal - 1) % guaranteeTimes) * guaranteeMap.get(entry.id);
                    }
                }

                // 如果随机数落在entry的区间最大值之下则表示命中
                if (randNum <= entry.ceil + rangeExtended) {
                    // 命中，计算可以得到的道具个数（也是随机出来的）
                    int num = Math.max(entry.minNum, random.nextInt(entry.maxNum + 1));
                    retList.add(new RewardItem(entry.id, num));

                    // 如果改对象有保底掉落需求，则保存对象命中计数
                    if (guaranteeRequired) {
                        poolStatsMap.put(itemHitKey, poolInvokeTotal);
                    }

                    // 只有类型为3的池是按万分比掉落而且一轮可以掉落多个，其他类型的一轮最多只能掉落1个
                    if (this.type != 3) {
                        break;
                    }
                }
            }
        }

        // 保存掉落池历史记录，下次掉落需要依赖本轮掉落的执行情况
        poolStats.savePoolStats();

        return retList;
    }

    private RewardEntry random(List<RewardEntry> entries, int n) {
        Random random = new Random(System.nanoTime());
        for (int i = 0; i < n; i++) {
            int randNum = random.nextInt(10000); // 产生一个随机数
            for (RewardEntry entry : entries) {
                if (randNum <= entry.ceil) {
                    return entry;
                }
            }
        }
        return null;
    }

    public static RewardPool parse(String input) {
        RewardPool pool = new RewardPool();

        try {
            List<RewardEntry> entries = new ArrayList<>();
            StringTokenizer tokenizer = new StringTokenizer(input, ",");

            while (tokenizer.hasMoreTokens()) {
                String token = tokenizer.nextToken();

                // 约定如果第一项为单独的数字，则表示类型，要不然没法区分奖励池类型(1:按权重掉落，<=1; 2: 掉落池组合；3：按万分比掉落）
                if (!token.contains("*")) {
                    pool.type = Integer.valueOf(token);
                    continue;
                }

                // 以下才是真正的解析掉落池中的每项
                //
                RewardEntry entry = new RewardEntry();
                String[] arr1 = token.split("\\*");
                entry.id = Integer.parseInt(arr1[0]);

                String[] arr2 = arr1[1].split(":");

                if (pool.type == 3) {
                    entry.ceil = Integer.valueOf(arr2[1]);
                } else {
                    entry.weight = Integer.valueOf(arr2[1]);
                }

                String range = arr2[0];
                if (range.indexOf("-") > 0) {
                    String[] arr3 = range.split("-");
                    entry.minNum = Integer.parseInt(arr3[0]);
                    entry.maxNum = Integer.parseInt(arr3[1]);
                } else {
                    entry.minNum = Integer.parseInt(range);
                    entry.maxNum = entry.minNum;
                }

                entries.add(entry);
            }

            if (pool.type != 3) {
                calcProbabilityByWeight(entries);
            }

            pool.entries = entries;
        } catch (Exception e) {
            LOGGER.error("{}", e);
        }

        return pool;
    }

    /**
     * 根据每个条目权重的大小，转换为相应的概率值上限，计算是否命中时都需要和这个概率上限值进行匹配
     */
    private static void calcProbabilityByWeight(List<RewardEntry> entries) {
        int totalWeight = 0, sum = 0, index = 0;

        // 累加得到合计权重值
        for (RewardEntry entry : entries) {
            totalWeight += entry.weight;
        }

        // 根据权重值计算概率上限
        for (RewardEntry entry : entries) {
            if (entry.weight > 0) {
                if (index++ < entries.size() - 1) {
                    int len = (int) Math.round(((double) entry.weight / totalWeight) * 10000);
                    entry.ceil = sum + len;
                    sum += len;
                } else {
                    entry.ceil = 10000;
                }
            } else {
                entry.ceil = 10000;
            }
        }
    }

    public static void main(String[] args) {
//        RewardPool bundle = RewardPool.parse("107*2-10:60,109*8-30:100,104*5-5:10,105*1-2:10");
//        Collection<RewardItem> items = bundle.random(10);
//        System.out.println(items);

//        RewardPool bundle = RewardPool.parse("107*2,109*8,104*5,105*1");
//        RewardPool bundle = RewardPool.parse("2200100*1-2:10,2301000*1-2:20,2301010*1-6:30,9000102*1-2:100,-1*1-1:500");

        RewardPool pool = RewardPool.parse("3,2200100*1-2:1,2301000*1-2:1,2301010*1-6:1,9000102*1-2:1,-1*1-1:1");

        Object result = pool.randomAsMap(4);
        System.out.println(result);

//        for (int i = 0; i < 10; i++) {
//            Collection<RewardItem> items = pool.random(1);
//            System.out.println(items != null ? items.iterator().next().getEntityId() : null);
//        }
    }
}
